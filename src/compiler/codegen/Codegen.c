#include <stdio.h>

#include "compiler/parser/ASTNodes.h"
#include "compiler/codegen/Instruction.h"
#include "compiler/codegen/Codegen.h"
#include "internal/String.h"
#include "internal/Array.h"
#include "assertf.h"


void __Codegen_generate(Codegen *codegen);
void __Codegen_generatePreamble(Codegen *codegen);
void __Codegen_generateVariableDeclaration(VariableDeclaration *variable, enum Frame frame);
void __Codegen_evaluateVariableInitializer(ExpressionASTNode *expression);
void __Codegen_generateGlobalVariables(Codegen *codegen);
void __Codegen_evaluateLiteral(LiteralExpressionASTNode *literal);
void __Codegen_walkAST(ASTNode *node);

void Codegen_constructor(Codegen *codegen, Analyser *analyser) {
    assertf(codegen != NULL);
    assertf(analyser != NULL);

    codegen->analyser = analyser;
}

//void Codegen_destructor(Codegen *codegen) {
//    assertf(codegen != NULL);
//    assertf(codegen->analyser != NULL);
//
//    codegen->analyser = NULL;
//}
//
//void Codegen_escapeString(String string) {
//
//}

void Codegen_generate(Codegen *codegen) {
    assertf(codegen != NULL);
    assertf(codegen->analyser != NULL);

    __Codegen_generate(codegen);
}


void __Codegen_generate(Codegen *codegen) {
    __Codegen_generatePreamble(codegen);

    __Codegen_generateGlobalVariables(codegen);


}

void __Codegen_generateGlobalVariables(Codegen *codegen) {
    Array *variables = HashMap_values(codegen->analyser->variables);
    for (size_t i = 0; i < variables->size; i++) {
        VariableDeclaration *declaration = (VariableDeclaration *) Array_get(variables, i);
        __Codegen_generateVariableDeclaration(declaration, FRAME_GLOBAL);
    }
}

void __Codegen_generatePreamble(Codegen *codegen) {
    if (!codegen) return;

    COMMENT("Generated by IFJ2023 compiler")
    HEADER
    NEWLINE
}

void __Codegen_generateVariableDeclaration(VariableDeclaration *variable, enum Frame frame) {
    COMMENT_VAR(variable->id)
    Instruction_defvar(variable->id, frame == FRAME_GLOBAL ? "GF" : "LF");
    NEWLINE
}

void __Codegen_evaluateVariableInitializer(ExpressionASTNode *expression) {
    switch (expression->_type) {
        case NODE_LITERAL_EXPRESSION: {
            __Codegen_evaluateLiteral((LiteralExpressionASTNode *) expression);
        }
        case NODE_UNARY_EXPRESSION:
            break;
        case NODE_BINARY_EXPRESSION:
            break;
        case NODE_IDENTIFIER:
            break;
        case NODE_FUNCTION_CALL:
            break;
        default: {
            fassertf("Unexpected expression type %d. Analyzer probably failed.", expression->_type);
        }
    }
}

void __Codegen_evaluateLiteral(LiteralExpressionASTNode *literal) {
    switch (literal->type.type) {
        case TYPE_NIL:
            Instruction_pushs_nil();
            break;
        case TYPE_UNKNOWN:
            break;
        case TYPE_INVALID:
            break;
        case TYPE_INT:
            Instruction_pushs_int(literal->value.integer);
            break;
        case TYPE_DOUBLE:
            Instruction_pushs_float(literal->value.floating);
            break;
        case TYPE_BOOL:
            Instruction_pushs_bool(literal->value.boolean);
            break;
        case TYPE_STRING:
            Instruction_pushs_string(literal->value.string);
            break;
        case TYPE_VOID:
            // TODO: Careful, you need to think this through
            break;
    }
}

void Codegen_escapeString(String *string) {
    assertf(string != NULL);
}