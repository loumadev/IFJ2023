#include <stdio.h>

#include "compiler/parser/ASTNodes.h"
#include "compiler/codegen/Instruction.h"
#include "compiler/codegen/Codegen.h"
#include "internal/String.h"
#include "internal/Array.h"
#include "assertf.h"


void __Codegen_generate(Codegen *codegen);

void __Codegen_generatePreamble();

void __Codegen_generateVariableDeclaration(Codegen *codegen, VariableDeclaration *variable);

void __Codegen_evaluateVariableExpression(__attribute__((unused)) Codegen *codegen, ExpressionASTNode *expression);

void __Codegen_generateGlobalVariablesDeclarations(Codegen *codegen);

__attribute__((unused)) void __Codegen_generateFunctionsDeclarations(Codegen *codegen);

void __Codegen_generateFunctionDeclaration(__attribute__((unused)) Codegen *codegen, FunctionDeclaration *function);

void __Codegen_evaluateLiteral(__attribute__((unused)) __attribute__((unused)) Codegen *codegen,
                               LiteralExpressionASTNode *literal);

// Walking AST functions
void __Codegen_walkAST(Codegen *codegen);

void __Codegen_processBlock(__attribute__((unused)) Codegen *codegen, BlockASTNode *block);

void __Codegen_processStatement(Codegen *codegen, StatementASTNode *statementAstNode);

void __Codegen_processBinaryOperator(__attribute__((unused)) Codegen *codegen, BinaryExpressionASTNode *expression);


void Codegen_constructor(Codegen *codegen, Analyser *analyser) {
    assertf(codegen != NULL);
    assertf(analyser != NULL);

    codegen->analyser = analyser;
    codegen->frame = FRAME_GLOBAL;
}

//void Codegen_destructor(Codegen *codegen) {
//    assertf(codegen != NULL);
//    assertf(codegen->analyser != NULL);
//
//    codegen->analyser = NULL;
//}
//
//void Codegen_escapeString(String string) {
//
//}

void Codegen_generate(Codegen *codegen) {
    assertf(codegen != NULL);
    assertf(codegen->analyser != NULL);

    __Codegen_generate(codegen);
}


void __Codegen_generate(Codegen *codegen) {
    __Codegen_generatePreamble();
    __Codegen_generateGlobalVariablesDeclarations(codegen);
    __Codegen_walkAST(codegen);
}

void __Codegen_generatePreamble() {
    COMMENT("Generated by IFJ2023 compiler")
    HEADER
    NEWLINE
}

void __Codegen_generateGlobalVariablesDeclarations(Codegen *codegen) {
    Array *variables = HashMap_values(codegen->analyser->variables);
    for (size_t i = 0; i < variables->size; i++) {
        VariableDeclaration *declaration = (VariableDeclaration *) Array_get(variables, i);
        __Codegen_generateVariableDeclaration(codegen, declaration);
    }
}

void __Codegen_generateVariableDeclaration(Codegen *codegen, VariableDeclaration *variable) {
    COMMENT_VAR(variable->id)
    Instruction_defvar(variable->id, codegen->frame);
    NEWLINE
}

__attribute__((unused)) void __Codegen_generateFunctionsDeclarations(Codegen *codegen) {
    Array *functions = HashMap_values(codegen->analyser->functions);
    for (size_t i = 0; i < functions->size; i++) {
        FunctionDeclaration *declaration = (FunctionDeclaration *) Array_get(functions, i);
        __Codegen_generateFunctionDeclaration(codegen, declaration);
    }
}

void __Codegen_generateFunctionDeclaration(__attribute__((unused)) Codegen *codegen, FunctionDeclaration *function) {
    COMMENT_FUNC(function->id)

    FunctionDeclarationASTNode *node = function->node;
    Instruction_label_func_start(function->id);
    Instruction_pushframe();

    if (node->returnType->type.type != TYPE_VOID) {
        Instruction_defretvar(function->id, FRAME_LOCAL);
    }

}

void __Codegen_walkAST(Codegen *codegen) {
    BlockASTNode *block = codegen->analyser->ast->block;
    __Codegen_processBlock(codegen, block);
}

void __Codegen_processBlock(Codegen *codegen, BlockASTNode *block) {
    Array *statements = block->statements;

    for (size_t i = 0; i < statements->size; ++i) {
        StatementASTNode *statement = Array_get(statements, i);
        __Codegen_processStatement(codegen, statement);
    }
}

void __Codegen_processStatement(Codegen *codegen, StatementASTNode *statement) {
    switch (statement->_type) {
        case NODE_IF_STATEMENT: {
            IfStatementASTNode * ifStatement = (IfStatementASTNode *) statement;

            switch (ifStatement->test->_type) {
                case NODE_OPTIONAL_BINDING_CONDITION: {
                    // TODO: Implement (if-let)
                } break;
                case NODE_EXPRESSION_STATEMENT: {

                } break;
                default:
                    fassertf("Unexpected ASTNode type. Analyser probably failed.");
            }
        }
            break;
        case NODE_WHILE_STATEMENT: {
            WhileStatementASTNode * whileStatement = (WhileStatementASTNode *) statement;
            // Start label
            // TODO: This should be dynamic
            size_t id = 1;
            Instruction_label_while_start(id);

            // Process test
            __Codegen_processStatement(codegen, (StatementASTNode *) whileStatement->test);
            Instruction_pushs_bool(true);

            // Make actual test
            Instruction_jumpifneqs_while_end(id);
            Instruction_clears();

            // Process body
            __Codegen_processBlock(codegen, whileStatement->body);

            // At end, go to begging for test
            Instruction_jump_while_start(id);

            // End of loop, clear stack
            Instruction_label_while_end(id);
            Instruction_clears();
        }
            break;
        case NODE_FUNCTION_DECLARATION: {
            FunctionDeclarationASTNode *funcDeclaration = (FunctionDeclarationASTNode *) statement;
            Instruction_jump_func_end(funcDeclaration->id->id);

            Instruction_label_func_end(funcDeclaration->id->id);
        }
            break;
        case NODE_BINARY_EXPRESSION: {
            BinaryExpressionASTNode *expression = (BinaryExpressionASTNode *) statement;
            __Codegen_processStatement(codegen, (StatementASTNode *) expression->left);
            __Codegen_processStatement(codegen, (StatementASTNode *) expression->right);
            __Codegen_processBinaryOperator(codegen, expression);
        } break;
            // unwrap - ignore
        case NODE_UNARY_EXPRESSION:
            break;
        case NODE_LITERAL_EXPRESSION: {
            LiteralExpressionASTNode *literal = (LiteralExpressionASTNode *) statement;
            __Codegen_evaluateLiteral(codegen, literal);
        }
            break;
        case NODE_FUNCTION_CALL:
            break;
            // var a = 1
        case NODE_VARIABLE_DECLARATION: {
            VariableDeclarationASTNode *node = (VariableDeclarationASTNode *) statement;
            __Codegen_processStatement(codegen, (StatementASTNode *) node->declaratorList);
        }
            break;

            // var a = 1, b = 2, c = 3
        case NODE_VARIABLE_DECLARATION_LIST: {
            VariableDeclarationListASTNode *declarationNode = (VariableDeclarationListASTNode *) statement;
            Array *declarators = declarationNode->declarators;
            for (size_t i = 0; i < declarators->size; ++i) {
                VariableDeclaratorASTNode *declaratorNode = Array_get(declarators, i);
                __Codegen_processStatement(codegen, (StatementASTNode *) declaratorNode);
            }
        }
            break;

            // a = 1, b = 2 (related ku NODE_VARIABLE_DECLARATION_LIST)
        case NODE_VARIABLE_DECLARATOR: {
            VariableDeclaratorASTNode *declaratorNode = (VariableDeclaratorASTNode *) statement;
            __Codegen_processStatement(codegen, (StatementASTNode *) declaratorNode->initializer);
            Instruction_pops(declaratorNode->pattern->id->id, codegen->frame);
            NEWLINE
        } break;

            // a = 1
        case NODE_ASSIGNMENT_STATEMENT: {
            AssignmentStatementASTNode *assignment = (AssignmentStatementASTNode *) statement;
            __Codegen_processStatement(codegen, (StatementASTNode *) assignment->expression);
            Instruction_pops(assignment->id->id, codegen->frame);
            NEWLINE
        } break;
        // Len function call
        case NODE_EXPRESSION_STATEMENT: {
          ExpressionStatementASTNode * expressionStatement = (ExpressionStatementASTNode *) statement;
            __Codegen_processStatement(codegen, (StatementASTNode *) expressionStatement->expression);
        } break;

        case NODE_RETURN_STATEMENT:
            break;

        case NODE_IDENTIFIER: {
            IdentifierASTNode *identifier = (IdentifierASTNode *) statement;
            Instruction_pushs_var(identifier->id, codegen->frame);
        }
            break;
        case NODE_INVALID:
        case NODE_PROGRAM:
        case NODE_BLOCK:
        case NODE_TYPE_REFERENCE:
        case NODE_PARAMETER:
        case NODE_PARAMETER_LIST:
        case NODE_ARGUMENT:
        case NODE_ARGUMENT_LIST:
        case NODE_PATTERN:
        case NODE_OPTIONAL_BINDING_CONDITION:
            fassertf("Unexpected ASTNode type. Analyser probably failed.");
    }
}

// TODO: Finish
//void __Codegen_evaluateVariableExpression(Codegen *codegen, ExpressionASTNode *expression) {
//    switch (expression->_type) {
//        case NODE_LITERAL_EXPRESSION: {
//            __Codegen_evaluateLiteral(codegen, (LiteralExpressionASTNode *) expression);
//        } break;
//        case NODE_UNARY_EXPRESSION:
//            break;
//        case NODE_BINARY_EXPRESSION:
//            break;
//        case NODE_IDENTIFIER:
//            break;
//        case NODE_FUNCTION_CALL:
//            break;
//        default: {
//            fassertf("Unexpected expression type %d. Analyzer probably failed.", expression->_type);
//        }
//    }
//}

// TODO: Careful, there are some exceptions when working with nils
void __Codegen_processBinaryOperator(__attribute__((unused)) Codegen *codegen, BinaryExpressionASTNode *expression) {
    switch (expression->operator) {
        case OPERATOR_PLUS:
            return Instruction_adds();
        case OPERATOR_MINUS:
            return Instruction_subs();
        case OPERATOR_MUL: {
            return Instruction_muls();
            case OPERATOR_DIV:
                return Instruction_divs();
            case OPERATOR_UNWRAP:
                // TODO: Implement
                break;
            case OPERATOR_NULL_COALESCING:
                // TODO: Implement
                break;
            case OPERATOR_EQUAL:
                return Instruction_eqs();
            case OPERATOR_NOT_EQUAL:
                Instruction_eqs();
            Instruction_nots();
            return;
            case OPERATOR_LESS:
                return Instruction_lts();
            case OPERATOR_GREATER:
                return Instruction_gts();
            case OPERATOR_LESS_EQUAL:
                Instruction_gts();
            // Negation of < is =>
            Instruction_nots();
            return;
            case OPERATOR_GREATER_EQUAL:
                Instruction_lts();
            // Negation of > is <=
            Instruction_nots();
            return;
            case OPERATOR_NOT:
                return Instruction_nots();
            case OPERATOR_OR:
                return Instruction_ors();
            case OPERATOR_AND:
                return Instruction_ands();
            case OPERATOR_DEFAULT: {
                fassertf("Unknown operator. Analysis probably failed.");
            }
        }
    }
}

void __Codegen_evaluateLiteral(__attribute__((unused)) Codegen *codegen, LiteralExpressionASTNode *literal) {
    switch (literal->type.type) {
        case TYPE_NIL:
            Instruction_pushs_nil();
            break;
        case TYPE_UNKNOWN:
            break;
        case TYPE_INVALID:
            break;
        case TYPE_INT:
            Instruction_pushs_int(literal->value.integer);
            break;
        case TYPE_DOUBLE:
            Instruction_pushs_float(literal->value.floating);
            break;
        case TYPE_BOOL:
            Instruction_pushs_bool(literal->value.boolean);
            break;
        case TYPE_STRING:
            Instruction_pushs_string(literal->value.string);
            break;
        case TYPE_VOID:
            // TODO: Careful, you need to think this through
            break;
    }
}

//void Codegen_escapeString(String *string) {
//    assertf(string != NULL);
//}